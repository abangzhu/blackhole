<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>åŸå¸‚é»‘æ´åå™¬ 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; -webkit-user-select: none; }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
            z-index: 10;
        }
        h1 { margin: 0; font-size: 1.5rem; }
        #score-board { font-size: 1.2rem; margin-top: 5px; }
        
        #win-screen {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 20;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        #win-screen.active {
            opacity: 1;
            pointer-events: all;
        }
        button {
            padding: 15px 30px;
            font-size: 1.2rem;
            background: #ff4757;
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(255, 71, 87, 0.4);
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }
        
        /* Loading overlay */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #2f3542; display: flex; justify-content: center; align-items: center;
            color: white; z-index: 100;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <h1>åŸå¸‚é»‘æ´</h1>
        <div id="score-board">é€²åº¦: 0 / 0</div>
        <div id="size-info">é»‘æ´ç­‰ç´š: 1</div>
    </div>

    <div id="win-screen">
        <h1 style="font-size: 3rem; margin-bottom: 20px;">ğŸ‰ éŠæˆ²å‹åˆ©! ğŸ‰</h1>
        <p>ä½ åå™¬äº†æ•´åº§åŸå¸‚ï¼</p>
        <button id="restart-btn">é‡æ–°é–‹å§‹éŠæˆ²</button>
    </div>

    <div id="loader">è¼‰å…¥ä¸­...</div>

    <!-- Import Three.js from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- å…¨å±€è®Šé‡ ---
        let scene, camera, renderer;
        let hole;
        let objects = []; // å­˜å„²å¯åå™¬ç‰©é«”
        let eatingObjects = []; // æ­£åœ¨è¢«åå™¬å‹•ç•«ä¸­çš„ç‰©é«”
        
        // éŠæˆ²ç‹€æ…‹
        let gameData = {
            totalObjects: 0,
            eatenCount: 0,
            holeRadius: 2.0,  // åˆå§‹å°ºå¯¸å¢å¤§
            holeLevel: 1,
            isPlaying: true
        };

        // é¡è‰²é…ç½®
        const COLORS = {
            ground: 0xe0e0e0,
            road: 0x555555,
            grass: 0x7cfc00,
            treeTrunk: 0x8B4513,
            treeLeaves: 0x228B22,
            buildingRes: [0xffcccc, 0xccffcc, 0xccccff],
            buildingCom: [0x607d8b, 0x455a64, 0x90a4ae],
            car: [0xff4757, 0x2ed573, 0x1e90ff, 0xffa502]
        };

        // å°„ç·šæª¢æ¸¬ç”¨æ–¼æ§åˆ¶
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const planeTarget = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        let targetPosition = new THREE.Vector3(0, 0.05, 0); // ç›®æ¨™ä½ç½®
        
        // åˆå§‹åŒ–
        function init() {
            // 1. å ´æ™¯è¨­ç½®
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // å¤©ç©ºè—
            scene.fog = new THREE.Fog(0x87CEEB, 30, 90);

            // 2. ç›¸æ©Ÿè¨­ç½® (é©é…è±å±)
            const aspect = window.innerWidth / window.innerHeight;
            // æ ¹æ“šå±å¹•æ¯”ä¾‹èª¿æ•´è¦–è§’ç¯„åœï¼Œç¢ºä¿è±å±èƒ½çœ‹åˆ°è¶³å¤ å¤šçš„å…§å®¹
            const frustumSize = 40; 
            camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2, 
                frustumSize * aspect / 2, 
                frustumSize / 2, 
                frustumSize / -2, 
                1, 
                1000
            );
            camera.position.set(20, 40, 20); // ISO è¦–è§’
            camera.lookAt(0, 0, 0);

            // 3. æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 4. ç‡ˆå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 5. å‰µå»ºéŠæˆ²ä¸–ç•Œ
            createWorld();

            // 6. å‰µå»ºç©å®¶ï¼ˆé»‘æ´ï¼‰
            createHole();

            // 7. äº‹ä»¶ç›£è½
            window.addEventListener('resize', onWindowResize);
            
            // è§¸æ§/æ»‘é¼ æ§åˆ¶
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false }); // é˜²æ­¢æ»¾å‹•

            document.getElementById('restart-btn').addEventListener('click', restartGame);

            // éš±è—åŠ è¼‰ç•«é¢
            document.getElementById('loader').style.display = 'none';
            
            animate();
        }

        // --- ä¸–ç•Œç”Ÿæˆé‚è¼¯ ---
        function createWorld() {
            // åœ°é¢
            const groundGeo = new THREE.PlaneGeometry(100, 100);
            const groundMat = new THREE.MeshStandardMaterial({ color: COLORS.ground });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // æ¸…ç©ºèˆŠç‰©é«”
            objects.forEach(obj => scene.remove(obj.mesh));
            objects = [];
            gameData.totalObjects = 0;

            // ç”ŸæˆåŸå¸‚ä½ˆå±€
            // ç°¡å–®ç¶²æ ¼ä½ˆå±€ï¼š
            // ä½å®…å€ (-30, -30) åˆ° (0, 0)
            // å…¬åœ’å€ (0, -30) åˆ° (30, 0)
            // å•†æ¥­å€ (-30, 0) åˆ° (30, 30)
            
            // 1. å…¬åœ’ (æ¨¹æœ¨, é•·æ¤…)
            for (let i = 0; i < 40; i++) {
                const x = Math.random() * 30 + 2;
                const z = Math.random() * 30 - 32;
                const type = Math.random() > 0.3 ? 'tree' : 'bench';
                createObject(type, x, z);
            }
            // å…¬åœ’ç¶ åœ°åº•æ¿
            const parkGeo = new THREE.PlaneGeometry(35, 35);
            const parkMat = new THREE.MeshStandardMaterial({ color: COLORS.grass });
            const park = new THREE.Mesh(parkGeo, parkMat);
            park.rotation.x = -Math.PI / 2;
            park.position.set(17.5, 0.01, -17.5);
            park.receiveShadow = true;
            scene.add(park);

            // 2. ä½å®…å€ (å°æˆ¿å­, è»Š, åœæ¬„)
            for (let x = -35; x < -5; x += 10) {
                for (let z = -35; z < -5; z += 10) {
                    createObject('house', x + Math.random()*2, z + Math.random()*2);
                    if(Math.random() > 0.5) createObject('car', x + 6, z + 2);
                    createObject('fence', x + 5, z + 5);
                }
            }

            // 3. å•†æ¥­å€ (é«˜æ¨“, å»£å‘Šç‰Œ, æ›´å¤šè»Š)
            for (let x = -30; x < 30; x += 12) {
                for (let z = 5; z < 35; z += 12) {
                    createObject('skyscraper', x, z);
                    if(Math.random() > 0.3) createObject('car', x + 6, z - 2);
                    createObject('lamp', x + 5, z + 5);
                }
            }
            
            // é“è·¯ (è¦–è¦ºè£é£¾)
            const roadGeo = new THREE.PlaneGeometry(100, 8);
            const roadMat = new THREE.MeshStandardMaterial({ color: COLORS.road });
            const road1 = new THREE.Mesh(roadGeo, roadMat);
            road1.rotation.x = -Math.PI / 2;
            road1.position.set(0, 0.02, 0);
            road1.receiveShadow = true;
            scene.add(road1);
            
            const road2 = road1.clone();
            road2.rotation.z = Math.PI / 2;
            scene.add(road2);

            // éš¨æ©Ÿæ•£è½ä¸€äº›è¡Œäºº(å°åœ“æŸ±)å’Œé›œç‰©
            for(let i=0; i<30; i++) {
                const x = (Math.random() - 0.5) * 70;
                const z = (Math.random() - 0.5) * 70;
                if (Math.abs(x) < 5 && Math.abs(z) < 5) continue; // ä¸è¦ç”Ÿæˆåœ¨ä¸­å¿ƒ
                createObject('pedestrian', x, z);
            }

            updateUI();
        }

        // å‰µå»ºå–®å€‹ç‰©é«”çš„è¼”åŠ©å‡½æ•¸
        function createObject(type, x, z) {
            let mesh, colliderRadius, scoreValue, requiredSize;
            
            switch(type) {
                case 'pedestrian':
                    const pedGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 8);
                    const pedMat = new THREE.MeshStandardMaterial({ color: 0xffccaa });
                    mesh = new THREE.Mesh(pedGeo, pedMat);
                    mesh.position.set(x, 0.6, z);
                    colliderRadius = 0.8;
                    requiredSize = 0.5; // æœ€å°å¯åƒ
                    scoreValue = 1;
                    break;
                case 'fence':
                case 'bench':
                    const boxGeo = new THREE.BoxGeometry(1.5, 0.8, 0.5);
                    const boxMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                    mesh = new THREE.Mesh(boxGeo, boxMat);
                    mesh.position.set(x, 0.4, z);
                    colliderRadius = 1.5;
                    requiredSize = 1.0;
                    scoreValue = 2;
                    break;
                case 'lamp':
                    mesh = new THREE.Group();
                    const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 4), new THREE.MeshStandardMaterial({color:0x333333}));
                    pole.position.y = 2;
                    const light = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.2, 0.4), new THREE.MeshStandardMaterial({color:0xffffee, emissive:0xffffaa}));
                    light.position.y = 4;
                    mesh.add(pole, light);
                    mesh.position.set(x, 0, z);
                    colliderRadius = 1.2;
                    requiredSize = 1.2;
                    scoreValue = 3;
                    break;
                case 'tree':
                    mesh = new THREE.Group();
                    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 1.5), new THREE.MeshStandardMaterial({color: COLORS.treeTrunk}));
                    trunk.position.y = 0.75;
                    const leaves = new THREE.Mesh(new THREE.ConeGeometry(1.5, 3, 8), new THREE.MeshStandardMaterial({color: COLORS.treeLeaves}));
                    leaves.position.y = 2.5;
                    mesh.add(trunk, leaves);
                    mesh.position.set(x, 0, z);
                    colliderRadius = 2.0;
                    requiredSize = 1.5;
                    scoreValue = 5;
                    break;
                case 'car':
                    const carColor = COLORS.car[Math.floor(Math.random() * COLORS.car.length)];
                    mesh = new THREE.Mesh(new THREE.BoxGeometry(2, 1.2, 4), new THREE.MeshStandardMaterial({color: carColor}));
                    mesh.position.set(x, 0.6, z);
                    colliderRadius = 2.5;
                    requiredSize = 2.0;
                    scoreValue = 10;
                    break;
                case 'house':
                    mesh = new THREE.Group();
                    const body = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 4), new THREE.MeshStandardMaterial({color: COLORS.buildingRes[Math.floor(Math.random()*3)]}));
                    body.position.y = 1.5;
                    const roof = new THREE.Mesh(new THREE.ConeGeometry(3.5, 2, 4), new THREE.MeshStandardMaterial({color: 0x8B0000}));
                    roof.position.y = 4;
                    roof.rotation.y = Math.PI / 4;
                    mesh.add(body, roof);
                    mesh.position.set(x, 0, z);
                    colliderRadius = 4.0;
                    requiredSize = 3.5;
                    scoreValue = 30;
                    break;
                case 'skyscraper':
                    const height = 8 + Math.random() * 8;
                    mesh = new THREE.Mesh(new THREE.BoxGeometry(3.5, height, 3.5), new THREE.MeshStandardMaterial({color: COLORS.buildingCom[Math.floor(Math.random()*3)]}));
                    mesh.position.set(x, height/2, z);
                    colliderRadius = 4.5;
                    requiredSize = 4.5;
                    scoreValue = 50;
                    break;
            }

            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            objects.push({
                mesh: mesh,
                colliderRadius: colliderRadius,
                requiredSize: requiredSize,
                scoreValue: scoreValue,
                active: true,
                initialY: mesh.position.y
            });
            
            gameData.totalObjects++;
        }

        // --- é»‘æ´é‚è¼¯ ---
        function createHole() {
            // é»‘æ´è¦–è¦ºï¼šä¸€å€‹é»‘è‰²çš„åœ“æŸ±é«”ï¼Œæ¥µæ‰ï¼Œæ”¾åœ¨åœ°é¢ç¨ä¸Šæ–¹
            const geometry = new THREE.CylinderGeometry(1, 1, 0.1, 64);
            // ä½¿ç”¨ Basic æè³ªç´”é»‘ï¼Œä¸åå…‰
            const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
            hole = new THREE.Mesh(geometry, material);
            hole.position.set(0, 0.05, 0); // ç•¥é«˜æ–¼åœ°é¢ï¼Œè“‹ä½åœ°é¢ç´‹ç†
            // çµ¦é»‘æ´åŠ ä¸€å€‹ç™¼å…‰çš„é‚Šç·£ç’°ï¼Œå¢åŠ è¦–è¦ºæ•ˆæœ
            const ringGeo = new THREE.RingGeometry(0.9, 1.05, 64);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xaa00ff, side: THREE.DoubleSide });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 0.06;
            hole.add(ring);

            scene.add(hole);
            updateHoleSize();
        }

        function updateHoleSize() {
            const scale = gameData.holeRadius;
            hole.scale.set(scale, 1, scale);
        }

        // --- æ§åˆ¶é‚è¼¯ ---
        function onPointerMove(event) {
            if (!gameData.isPlaying) return;

            // è™•ç†è§¸æ‘¸å’Œé¼ æ¨™
            let clientX, clientY;
            if (event.changedTouches) {
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersection = new THREE.Vector3();
            raycaster.ray.intersectPlane(planeTarget, intersection);

            if (intersection) {
                // é™åˆ¶åœ¨åœ°åœ–ç¯„åœå…§
                intersection.x = Math.max(-45, Math.min(45, intersection.x));
                intersection.z = Math.max(-45, Math.min(45, intersection.z));
                
                // æ›´æ–°ç›®æ¨™ä½ç½®
                targetPosition.set(intersection.x, 0.05, intersection.z);
            }
        }
        
        // æ›´æ–°é»‘æ´ä½ç½®ï¼ˆæ ¹æ“šå°ºå¯¸èª¿æ•´é€Ÿåº¦ï¼‰
        function updateHolePosition() {
            // è¨ˆç®—ç§»å‹•é€Ÿåº¦ï¼šéš¨è‘—é»‘æ´è®Šå¤§è€Œæ¸›æ…¢
            // åŸºç¤é€Ÿåº¦ 0.15ï¼Œéš¨è‘—åŠå¾‘å¢åŠ è€Œé™ä½
            // å…¬å¼ï¼šé€Ÿåº¦ = åŸºç¤é€Ÿåº¦ / (1 + åŠå¾‘å¢é•·æ¯”ä¾‹)
            const speedFactor = 0.15 / (1 + (gameData.holeRadius - 2.0) * 0.3);
            
            // ä½¿ç”¨ lerp å¹³æ»‘ç§»å‹•åˆ°ç›®æ¨™ä½ç½®
            hole.position.lerp(targetPosition, speedFactor);
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 40;
            
            camera.left = -frustumSize * aspect / 2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = -frustumSize / 2;
            
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- éŠæˆ²ä¸»å¾ªç’° ---
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameData.isPlaying) {
                updateHolePosition(); // æ›´æ–°é»‘æ´ä½ç½®ï¼ˆæ ¹æ“šå°ºå¯¸èª¿æ•´é€Ÿåº¦ï¼‰
                checkCollisions();
                handleEatingAnimations();
                
                // ç›¸æ©Ÿè·Ÿéš¨é»‘æ´
                const targetPos = new THREE.Vector3(
                    hole.position.x + 20, 
                    hole.position.y + 40, 
                    hole.position.z + 20
                );
                camera.position.lerp(targetPos, 0.1);
            }
            
            renderer.render(scene, camera);
        }

        function checkCollisions() {
            const holePos = hole.position;
            const holeR = gameData.holeRadius;

            objects.forEach(obj => {
                if (!obj.active) return;

                // è¨ˆç®—è·é›¢ (å¿½ç•¥Yè»¸)
                const dx = obj.mesh.position.x - holePos.x;
                const dz = obj.mesh.position.z - holePos.z;
                const dist = Math.sqrt(dx*dx + dz*dz);

                // åˆ¤æ–·æ˜¯å¦æ¥è§¸ç¯„åœï¼šç‰©é«”ç¢°æ’åŠå¾‘ + é»‘æ´åŠå¾‘
                // æ¢ä»¶ï¼šè·é›¢å°æ–¼å…©è€…åŠå¾‘ä¹‹å’Œï¼Œä¸”é»‘æ´å°ºå¯¸å¤§æ–¼ç‰©é«”éœ€æ±‚å°ºå¯¸
                const touchDistance = obj.colliderRadius + holeR * 0.5;
                if (dist < touchDistance && gameData.holeRadius >= obj.requiredSize) {
                    startEating(obj);
                }
            });
        }

        function startEating(obj) {
            obj.active = false;
            eatingObjects.push(obj);
        }

        function handleEatingAnimations() {
            for (let i = eatingObjects.length - 1; i >= 0; i--) {
                const obj = eatingObjects[i];
                
                // å‹•ç•«ï¼šè®Šå° + å‘ä¸‹ç§»å‹• + å‘é»‘æ´ä¸­å¿ƒç§»å‹•
                obj.mesh.scale.multiplyScalar(0.85); // å¿«é€Ÿç¸®å°
                obj.mesh.position.y -= 0.5; // ä¸‹å¢œ
                
                // å‘é»‘æ´ä¸­å¿ƒå¸å…¥
                obj.mesh.position.x += (hole.position.x - obj.mesh.position.x) * 0.2;
                obj.mesh.position.z += (hole.position.z - obj.mesh.position.z) * 0.2;

                if (obj.mesh.scale.x < 0.05) {
                    // åƒå®Œäº†
                    scene.remove(obj.mesh);
                    eatingObjects.splice(i, 1);
                    
                    // æ›´æ–°éŠæˆ²æ•¸æ“š
                    gameData.eatenCount++;
                    
                    // å¢åŠ é»‘æ´å°ºå¯¸ (èª¿é«˜æˆé•·ç³»æ•¸ï¼Œæ›´å¿«è®Šå¤§)
                    const growAmount = 0.15 * (obj.scoreValue / 10); // å¾ 0.05 å¢åŠ åˆ° 0.15
                    gameData.holeRadius += growAmount;
                    updateHoleSize();
                    
                    updateUI();
                    checkWin();
                }
            }
        }

        function updateUI() {
            document.getElementById('score-board').innerText = `é€²åº¦: ${gameData.eatenCount} / ${gameData.totalObjects}`;
            
            // æ ¹æ“šåŠå¾‘é¡¯ç¤ºç­‰ç´š
            let level = 1;
            if (gameData.holeRadius > 1.5) level = 2; // å¯ä»¥åƒæ¨¹
            if (gameData.holeRadius > 2.0) level = 3; // å¯ä»¥åƒè»Š
            if (gameData.holeRadius > 3.5) level = 4; // å¯ä»¥åƒæˆ¿å­
            if (gameData.holeRadius > 4.5) level = "MAX"; // å“¥å‰æ‹‰ç­‰ç´š
            
            document.getElementById('size-info').innerText = `é»‘æ´ç­‰ç´š: ${level}`;
        }

        function checkWin() {
            if (gameData.eatenCount >= gameData.totalObjects) {
                gameData.isPlaying = false;
                const winScreen = document.getElementById('win-screen');
                winScreen.style.display = 'flex';
                // å¼·åˆ¶é‡æ’ä»¥è§¸ç™¼éæ¸¡
                winScreen.offsetHeight; 
                winScreen.classList.add('active');
            }
        }

        function restartGame() {
            const winScreen = document.getElementById('win-screen');
            winScreen.classList.remove('active');
            setTimeout(() => { winScreen.style.display = 'none'; }, 500);

            // é‡ç½®æ•¸æ“š
            gameData.eatenCount = 0;
            gameData.holeRadius = 2.0;  // èˆ‡åˆå§‹å€¼ä¿æŒä¸€è‡´
            gameData.isPlaying = true;
            
            hole.position.set(0, 0.05, 0);
            targetPosition.set(0, 0.05, 0); // é‡ç½®ç›®æ¨™ä½ç½®
            updateHoleSize();
            
            // é‡æ–°ç”Ÿæˆä¸–ç•Œ
            createWorld();
        }

        // å•Ÿå‹•
        init();

    </script>
</body>
</html>
